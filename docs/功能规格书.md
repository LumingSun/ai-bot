# 桌面电子宠物系统功能规格书

## 1. 系统架构设计

### 1.1 整体架构
```
┌─────────────────────────────────────────────────────────────┐
│                    桌面电子宠物系统                          │
├─────────────────────────────────────────────────────────────┤
│  前端层 (Electron + React)                                │
│  ├── 悬浮窗口管理                                         │
│  ├── 宠物形象渲染                                         │
│  ├── 用户交互界面                                         │
│  └── 动画效果引擎                                         │
├─────────────────────────────────────────────────────────────┤
│  业务逻辑层 (Python + LangGraph)                          │
│  ├── 宠物状态管理                                         │
│  ├── 对话系统                                             │
│  ├── 性格系统                                             │
│  └── 定时任务管理                                         │
├─────────────────────────────────────────────────────────────┤
│  AI 服务层                                                │
│  ├── 大语言模型集成                                       │
│  ├── 对话生成引擎                                         │
│  └── 性格化响应系统                                       │
├─────────────────────────────────────────────────────────────┤
│  数据存储层                                               │
│  ├── SQLite 数据库                                        │
│  ├── 配置文件管理                                         │
│  └── 缓存系统                                             │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 模块划分
- **UI 模块**：负责界面显示和用户交互
- **宠物模块**：管理宠物状态、形象和行为
- **对话模块**：处理与大模型的交互
- **性格模块**：实现性格系统和行为逻辑
- **工具模块**：集成 LangGraph 和 MCP Server
- **存储模块**：管理数据持久化

## 2. 详细功能规格

### 2.1 桌面悬浮窗口模块

#### 2.1.1 窗口管理
```typescript
interface WindowManager {
  // 创建悬浮窗口
  createFloatingWindow(): Promise<void>;
  
  // 设置窗口位置
  setWindowPosition(x: number, y: number): void;
  
  // 设置窗口透明度
  setWindowOpacity(opacity: number): void;
  
  // 设置窗口置顶
  setAlwaysOnTop(alwaysOnTop: boolean): void;
  
  // 保存窗口状态
  saveWindowState(): void;
  
  // 恢复窗口状态
  restoreWindowState(): void;
}
```

#### 2.1.2 拖拽功能
```typescript
interface DragManager {
  // 启用拖拽
  enableDragging(): void;
  
  // 禁用拖拽
  disableDragging(): void;
  
  // 拖拽事件处理
  onDragStart(event: DragEvent): void;
  onDragMove(event: DragEvent): void;
  onDragEnd(event: DragEvent): void;
}
```

### 2.2 宠物形象模块

#### 2.2.1 宠物类型定义
```typescript
enum PetType {
  CAT = 'cat',
  DOG = 'dog',
  RABBIT = 'rabbit',
  HAMSTER = 'hamster'
}

interface PetAppearance {
  type: PetType;
  name: string;
  imageUrl: string;
  animations: AnimationConfig[];
  size: { width: number; height: number };
}
```

#### 2.2.2 动画系统
```typescript
interface AnimationConfig {
  name: string;
  duration: number;
  frames: Frame[];
  loop: boolean;
  trigger: AnimationTrigger;
}

interface AnimationTrigger {
  type: 'idle' | 'interaction' | 'emotion' | 'custom';
  condition?: string;
}
```

### 2.3 性格系统模块

#### 2.3.1 性格定义
```python
from enum import Enum
from dataclasses import dataclass
from typing import Dict, List

class PersonalityType(Enum):
    COLD = "cold"           # 高冷型
    CLINGY = "clingy"       # 粘人型
    PLAYFUL = "playful"     # 活泼型
    QUIET = "quiet"         # 安静型

@dataclass
class Personality:
    type: PersonalityType
    traits: Dict[str, float]  # 性格特征强度
    dialogue_style: Dict[str, str]  # 对话风格
    interaction_frequency: float  # 互动频率
    animation_preferences: List[str]  # 动画偏好
```

#### 2.3.2 性格生成器
```python
class PersonalityGenerator:
    def generate_random_personality(self) -> Personality:
        """随机生成宠物性格"""
        pass
    
    def get_personality_traits(self, personality_type: PersonalityType) -> Dict[str, float]:
        """获取指定性格类型的特征"""
        pass
    
    def get_dialogue_style(self, personality_type: PersonalityType) -> Dict[str, str]:
        """获取对话风格"""
        pass
```

### 2.4 对话系统模块

#### 2.4.1 对话管理器
```python
class DialogueManager:
    def __init__(self, personality: Personality, llm_client: LLMClient):
        self.personality = personality
        self.llm_client = llm_client
        self.conversation_history = []
    
    async def generate_response(self, user_input: str) -> str:
        """生成性格化对话响应"""
        pass
    
    async def generate_greeting(self) -> str:
        """生成主动问候"""
        pass
    
    def update_conversation_history(self, user_input: str, response: str):
        """更新对话历史"""
        pass
```

#### 2.4.2 大模型集成
```python
class LLMClient:
    def __init__(self, api_key: str, model: str = "gpt-3.5-turbo"):
        self.api_key = api_key
        self.model = model
    
    async def generate_response(self, prompt: str, personality_context: str) -> str:
        """调用大模型生成响应"""
        pass
    
    def format_prompt(self, user_input: str, personality: Personality, history: List) -> str:
        """格式化提示词"""
        pass
```

### 2.5 LangGraph 集成模块

#### 2.5.1 工作流定义
```python
from langgraph.graph import StateGraph, END
from typing import TypedDict, Annotated

class PetState(TypedDict):
    user_input: str
    personality: Personality
    context: Dict
    response: str
    tools_used: List[str]

class PetWorkflow:
    def __init__(self):
        self.graph = self.build_graph()
    
    def build_graph(self) -> StateGraph:
        """构建 LangGraph 工作流"""
        workflow = StateGraph(PetState)
        
        # 添加节点
        workflow.add_node("analyze_input", self.analyze_input)
        workflow.add_node("generate_response", self.generate_response)
        workflow.add_node("execute_tools", self.execute_tools)
        workflow.add_node("format_output", self.format_output)
        
        # 设置边
        workflow.add_edge("analyze_input", "generate_response")
        workflow.add_edge("generate_response", "execute_tools")
        workflow.add_edge("execute_tools", "format_output")
        workflow.add_edge("format_output", END)
        
        return workflow.compile()
    
    async def analyze_input(self, state: PetState) -> PetState:
        """分析用户输入"""
        pass
    
    async def generate_response(self, state: PetState) -> PetState:
        """生成响应"""
        pass
    
    async def execute_tools(self, state: PetState) -> PetState:
        """执行工具"""
        pass
    
    async def format_output(self, state: PetState) -> PetState:
        """格式化输出"""
        pass
```

#### 2.5.2 MCP Server 集成
```python
class MCPServerManager:
    def __init__(self):
        self.servers = {}
    
    async def register_server(self, name: str, server_config: Dict):
        """注册 MCP Server"""
        pass
    
    async def execute_tool(self, server_name: str, tool_name: str, params: Dict):
        """执行 MCP 工具"""
        pass
    
    def get_available_tools(self) -> List[Dict]:
        """获取可用工具列表"""
        pass
```

### 2.6 定时任务模块

#### 2.6.1 任务调度器
```python
import asyncio
from datetime import datetime, timedelta
from typing import Callable, Dict

class TaskScheduler:
    def __init__(self):
        self.tasks = {}
        self.running = False
    
    async def start(self):
        """启动任务调度器"""
        self.running = True
        await self.run_scheduler()
    
    async def stop(self):
        """停止任务调度器"""
        self.running = False
    
    async def add_task(self, name: str, func: Callable, interval: timedelta):
        """添加定时任务"""
        pass
    
    async def remove_task(self, name: str):
        """移除定时任务"""
        pass
    
    async def run_scheduler(self):
        """运行调度器主循环"""
        pass
```

#### 2.6.2 主动互动任务
```python
class ProactiveInteractionTask:
    def __init__(self, pet: Pet, personality: Personality):
        self.pet = pet
        self.personality = personality
    
    async def execute(self):
        """执行主动互动"""
        # 根据性格生成问候
        greeting = await self.generate_greeting()
        
        # 显示问候动画
        await self.pet.show_animation("greeting")
        
        # 发送问候消息
        await self.pet.send_message(greeting)
    
    async def generate_greeting(self) -> str:
        """根据性格生成问候语"""
        pass
```

### 2.7 数据存储模块

#### 2.7.1 数据库设计
```sql
-- 宠物表
CREATE TABLE pets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    type TEXT NOT NULL,
    personality_type TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 对话历史表
CREATE TABLE conversations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    pet_id INTEGER,
    user_input TEXT,
    pet_response TEXT,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (pet_id) REFERENCES pets(id)
);

-- 设置表
CREATE TABLE settings (
    key TEXT PRIMARY KEY,
    value TEXT,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 窗口状态表
CREATE TABLE window_state (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    x_position INTEGER,
    y_position INTEGER,
    opacity REAL,
    always_on_top BOOLEAN,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 2.7.2 数据管理器
```python
import sqlite3
from typing import Dict, List, Optional

class DatabaseManager:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """初始化数据库"""
        pass
    
    def save_pet(self, pet_data: Dict) -> int:
        """保存宠物信息"""
        pass
    
    def get_pet(self, pet_id: int) -> Optional[Dict]:
        """获取宠物信息"""
        pass
    
    def save_conversation(self, pet_id: int, user_input: str, response: str):
        """保存对话记录"""
        pass
    
    def get_conversation_history(self, pet_id: int, limit: int = 50) -> List[Dict]:
        """获取对话历史"""
        pass
    
    def save_setting(self, key: str, value: str):
        """保存设置"""
        pass
    
    def get_setting(self, key: str) -> Optional[str]:
        """获取设置"""
        pass
```

## 3. 接口定义

### 3.1 前端与后端通信接口

#### 3.1.1 IPC 通信
```typescript
// 前端发送消息
interface IPCMessage {
  type: string;
  data: any;
  id?: string;
}

// 后端响应
interface IPCResponse {
  success: boolean;
  data?: any;
  error?: string;
  id?: string;
}
```

#### 3.1.2 主要接口
```typescript
// 宠物相关接口
interface PetAPI {
  getPetInfo(): Promise<PetInfo>;
  updatePetInfo(petInfo: PetInfo): Promise<void>;
  changePetType(type: PetType): Promise<void>;
}

// 对话相关接口
interface DialogueAPI {
  sendMessage(message: string): Promise<string>;
  getConversationHistory(): Promise<ConversationRecord[]>;
}

// 设置相关接口
interface SettingsAPI {
  getSettings(): Promise<Settings>;
  updateSettings(settings: Partial<Settings>): Promise<void>;
  resetSettings(): Promise<void>;
}
```

### 3.2 外部 API 接口

#### 3.2.1 大模型 API
```python
class LLMAPI:
    def __init__(self, api_key: str, base_url: str = None):
        self.api_key = api_key
        self.base_url = base_url or "https://api.openai.com/v1"
    
    async def chat_completion(self, messages: List[Dict], model: str = "gpt-3.5-turbo") -> str:
        """调用聊天完成 API"""
        pass
    
    async def stream_chat_completion(self, messages: List[Dict], model: str = "gpt-3.5-turbo"):
        """流式调用聊天完成 API"""
        pass
```

#### 3.2.2 天气 API
```python
class WeatherAPI:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    async def get_current_weather(self, location: str) -> Dict:
        """获取当前天气"""
        pass
    
    async def get_weather_forecast(self, location: str, days: int = 3) -> List[Dict]:
        """获取天气预报"""
        pass
```

## 4. 配置管理

### 4.1 配置文件结构
```json
{
  "app": {
    "name": "Desktop Pet",
    "version": "1.0.0",
    "debug": false
  },
  "window": {
    "width": 300,
    "height": 400,
    "x": 100,
    "y": 100,
    "opacity": 0.9,
    "alwaysOnTop": true
  },
  "pet": {
    "type": "cat",
    "name": "小猫咪",
    "personality": "playful"
  },
  "llm": {
    "provider": "openai",
    "model": "gpt-3.5-turbo",
    "apiKey": "",
    "maxTokens": 1000,
    "temperature": 0.7
  },
  "interaction": {
    "greetingInterval": 300,
    "maxConversationHistory": 50,
    "enableProactiveInteraction": true
  },
  "tools": {
    "enableWeather": true,
    "enableReminder": true,
    "enableSchedule": false
  }
}
```

### 4.2 配置管理器
```python
import json
import os
from typing import Dict, Any

class ConfigManager:
    def __init__(self, config_path: str):
        self.config_path = config_path
        self.config = self.load_config()
    
    def load_config(self) -> Dict[str, Any]:
        """加载配置文件"""
        if os.path.exists(self.config_path):
            with open(self.config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        return self.get_default_config()
    
    def save_config(self):
        """保存配置文件"""
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(self.config, f, indent=2, ensure_ascii=False)
    
    def get(self, key: str, default: Any = None) -> Any:
        """获取配置值"""
        keys = key.split('.')
        value = self.config
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        return value
    
    def set(self, key: str, value: Any):
        """设置配置值"""
        keys = key.split('.')
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value
        self.save_config()
    
    def get_default_config(self) -> Dict[str, Any]:
        """获取默认配置"""
        return {
            "app": {
                "name": "Desktop Pet",
                "version": "1.0.0",
                "debug": False
            },
            "window": {
                "width": 300,
                "height": 400,
                "x": 100,
                "y": 100,
                "opacity": 0.9,
                "alwaysOnTop": True
            },
            "pet": {
                "type": "cat",
                "name": "小猫咪",
                "personality": "playful"
            },
            "llm": {
                "provider": "openai",
                "model": "gpt-3.5-turbo",
                "apiKey": "",
                "maxTokens": 1000,
                "temperature": 0.7
            },
            "interaction": {
                "greetingInterval": 300,
                "maxConversationHistory": 50,
                "enableProactiveInteraction": True
            },
            "tools": {
                "enableWeather": True,
                "enableReminder": True,
                "enableSchedule": False
            }
        }
```

## 5. 错误处理

### 5.1 错误类型定义
```python
class PetError(Exception):
    """宠物系统基础异常"""
    pass

class LLMError(PetError):
    """大模型相关异常"""
    pass

class NetworkError(PetError):
    """网络相关异常"""
    pass

class ConfigError(PetError):
    """配置相关异常"""
    pass
```

### 5.2 错误处理策略
```python
class ErrorHandler:
    def __init__(self):
        self.error_callbacks = {}
    
    def handle_error(self, error: Exception, context: str = ""):
        """处理错误"""
        error_type = type(error).__name__
        
        if error_type in self.error_callbacks:
            self.error_callbacks[error_type](error, context)
        else:
            self.log_error(error, context)
    
    def log_error(self, error: Exception, context: str):
        """记录错误日志"""
        pass
    
    def register_error_handler(self, error_type: str, handler: Callable):
        """注册错误处理器"""
        self.error_callbacks[error_type] = handler
```

## 6. 性能优化

### 6.1 缓存策略
```python
class CacheManager:
    def __init__(self):
        self.cache = {}
        self.max_size = 100
    
    def get(self, key: str) -> Any:
        """获取缓存值"""
        return self.cache.get(key)
    
    def set(self, key: str, value: Any, ttl: int = 3600):
        """设置缓存值"""
        if len(self.cache) >= self.max_size:
            self.evict_oldest()
        
        self.cache[key] = {
            'value': value,
            'expires_at': time.time() + ttl
        }
    
    def evict_oldest(self):
        """淘汰最旧的缓存项"""
        oldest_key = min(self.cache.keys(), 
                        key=lambda k: self.cache[k]['expires_at'])
        del self.cache[oldest_key]
```

### 6.2 资源管理
```python
class ResourceManager:
    def __init__(self):
        self.resources = {}
    
    def load_image(self, path: str) -> Any:
        """加载图片资源"""
        if path not in self.resources:
            self.resources[path] = self._load_image_file(path)
        return self.resources[path]
    
    def preload_resources(self, resource_list: List[str]):
        """预加载资源"""
        for resource in resource_list:
            self.load_image(resource)
    
    def cleanup_unused_resources(self):
        """清理未使用的资源"""
        pass
```

## 7. 测试策略

### 7.1 单元测试
```python
import unittest
from unittest.mock import Mock, patch

class TestPetSystem(unittest.TestCase):
    def setUp(self):
        """测试前准备"""
        self.pet = Pet()
        self.personality = PersonalityGenerator()
    
    def test_personality_generation(self):
        """测试性格生成"""
        personality = self.personality.generate_random_personality()
        self.assertIsNotNone(personality.type)
        self.assertIsInstance(personality.traits, dict)
    
    def test_dialogue_generation(self):
        """测试对话生成"""
        with patch('llm_client.generate_response') as mock_llm:
            mock_llm.return_value = "喵~你好！"
            response = self.pet.generate_response("你好")
            self.assertEqual(response, "喵~你好！")
    
    def test_window_management(self):
        """测试窗口管理"""
        window_manager = WindowManager()
        window_manager.set_position(100, 100)
        position = window_manager.get_position()
        self.assertEqual(position, (100, 100))
```

### 7.2 集成测试
```python
class TestIntegration(unittest.TestCase):
    async def test_full_conversation_flow(self):
        """测试完整对话流程"""
        # 初始化系统
        pet_system = PetSystem()
        await pet_system.initialize()
        
        # 发送消息
        response = await pet_system.send_message("你好")
        self.assertIsNotNone(response)
        
        # 检查对话历史
        history = pet_system.get_conversation_history()
        self.assertGreater(len(history), 0)
```

## 8. 部署方案

### 8.1 开发环境
```bash
# 安装依赖
npm install
pip install -r requirements.txt

# 启动开发服务器
npm run dev
python backend/main.py
```

### 8.2 生产环境
```bash
# 构建应用
npm run build
python setup.py build

# 打包
electron-builder
pyinstaller --onefile backend/main.py
```

### 8.3 更新机制
```python
class UpdateManager:
    def __init__(self):
        self.current_version = "1.0.0"
        self.update_url = "https://api.example.com/updates"
    
    async def check_for_updates(self) -> Optional[Dict]:
        """检查更新"""
        pass
    
    async def download_update(self, version: str) -> bool:
        """下载更新"""
        pass
    
    async def install_update(self, update_file: str) -> bool:
        """安装更新"""
        pass
``` 